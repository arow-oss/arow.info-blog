<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="author" content>

    <title>ARoW.info Blog -- Releasing a Haskell Web App on Heroku</title>

    <!-- Bootstrap Core CSS -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <!-- <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet"> -->

    <!-- Pandoc syntax highlighting CSS -->
    <link href="../css/syntax.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../css/clean-blog.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
								<a class="navbar-brand" href="//arow.info"><img height="30px" src="../img/logo.svg"></a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="//arow.info">Home</a>
                    </li>
                    <li>
                        <a href="../index.html">Blog</a>
                    </li>
                    <!-- <li> -->
                    <!--     <a href="/post.html">Sample Post</a> -->
                    <!-- </li> -->
                    <!-- <li> -->
                    <!--     <a href="/contact.html">Contact</a> -->
                    <!-- </li> -->
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
    <header class="intro-header" style="background-image: url('../img/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                  <div class="post-heading">
                    <h1>Releasing a Haskell Web App on Heroku</h1>
                    <h2 class="subheading">Using Heroku to serve a Servant App with Docker</h2><span class="meta">Posted by <a href="http://functor.tokyo">Dennis Gosnell</a></span>
                  </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>Releasing Haskell web applications on Heroku has become much easier with Heroku’s Docker support. This article explains how to deploy a Servant application on Heroku using Docker.</p>
<p>I’ve prepared an <a href="https://github.com/cdepillabout/servant-on-heroku">example application</a> you can use to try deploying to Heroku. This article is divided into three sections. The first section explains how to run the example application locally. The second section explains how to run the example application locally using Docker. The third section explains how to deploy this application to Heroku.</p>
<p>If you want to deploy to Heroku without running locally first, feel free to skim through the first and second sections. However, if you’re new to Haskell development, I recommend going through all three sections.</p>
<h2 id="running-the-application-locally-without-docker">Running the application locally WITHOUT Docker</h2>
<p>The example application is a small JSON API. It provides two APIs. One is to submit simple comments. The other is to display all comments that have been submitted. The comments are saved to a PostgreSQL database.</p>
<p>The following will walk through how to build and run the application locally, without involving Docker or Heroku.</p>
<h3 id="build-the-application-locally">Build the application locally</h3>
<p>First, clone the repository and build the application.</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> clone https://github.com/cdepillabout/servant-on-heroku
$ <span class="bu">cd</span> servant-on-heroku/
$ <span class="ex">stack</span> setup  # install the required version of ghc on your system
$ <span class="ex">stack</span> build  # install all dependencies and build the application</code></pre></div>
<p>An error may occur when building the application because of missing PostgreSQL libraries.</p>
<p>On Arch Linux, these missing PostgreSQL libraries can be installed with the following command:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> pacman -Ss postgresql-libs</code></pre></div>
<p>On Ubuntu, the following command can be used:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> apt-get install libpq-dev</code></pre></div>
<p>Other platforms may use a different command to install these libraries.</p>
<p>Once the required PostgreSQL libraries have been installed, try running <code>stack build</code> again. It should succeed this time.</p>
<p>Now try running the application:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">stack</span> exec -- servant-on-heroku-api</code></pre></div>
<p>Oops! It should fail with the following error:</p>
<pre><code>servant-on-heroku-api: libpq: failed (could not connect to server: Connection refused
        Is the server running on host &quot;localhost&quot; (::1) and accepting
        TCP/IP connections on port 5432?
        could not connect to server: Connection refused
        Is the server running on host &quot;localhost&quot; (127.0.0.1) and accepting
        TCP/IP connections on port 5432?
)</code></pre>
<p>The example application is trying to connect to PostgreSQL. Comments are stored in PostgreSQL, so you need PostgreSQL running locally.</p>
<h3 id="setup-postgresql">Setup PostgreSQL</h3>
<p>Most OSs and distributions will have different ways of installing PostgreSQL. Check with your platform documentation on how to install PostgreSQL.</p>
<p>For example, <a href="https://wiki.archlinux.org/index.php/PostgreSQL#Installing_PostgreSQL">here</a> is the Arch Linux documentation for installing PostgreSQL. <a href="https://help.ubuntu.com/community/PostgreSQL#Installation">Here</a> is the Ubuntu documentation.</p>
<p>Once PostgreSQL is installed and running, try running the application again:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">stack</span> exec -- servant-on-heroku-api</code></pre></div>
<p>Another oops! It should fail with the following error:</p>
<pre><code>servant-on-heroku-api: libpq: failed (FATAL:  role &quot;mydbuser&quot; does not exist
)</code></pre>
<p>Looks like a PostgreSQL user and database need to be setup for our application. If you check out the application source code (<code>src/Lib.hs</code>), you can see that it is reading in the <code>DATABASE_URL</code> environment variable and using it to connect to the PostgreSQL server.</p>
<p>If the <code>DATABASE_URL</code> environment variable is not specified, the application defaults to using:</p>
<pre><code>postgres://mydbuser:mydbpass@localhost:5432/mydb</code></pre>
<p>It is trying to use the user <code>mydbuser</code> with password <code>mydbpass</code> to access the database named <code>mydb</code>. Let’s create this user and database in PostgreSQL. The following commands are specific to Arch Linux. They may differ slightly if you are on a different platform. Check your platform documentation if they don’t seem to be working.</p>
<p>First, create the <code>mydbuser</code> user with password <code>mydbpass</code>:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> -u postgres -- psql --command <span class="st">&quot;CREATE ROLE mydbuser NOSUPERUSER NOCREATEDB NOCREATEROLE INHERIT LOGIN ENCRYPTED PASSWORD 'mydbpass'&quot;</span></code></pre></div>
<p>Create a database named <code>mydb</code>:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> -u postgres -- createdb mydb</code></pre></div>
<p>Make sure that <code>mydbuser</code> can access the <code>mydb</code> database:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> -u postgres -- psql --command <span class="st">&quot;GRANT ALL PRIVILEGES ON DATABASE mydb TO mydbuser&quot;</span></code></pre></div>
<p>PostgreSQL might need to be restarted:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">sudo</span> systemctl restart postgresql</code></pre></div>
<p>It should now be possible to connect to the <code>mydb</code> database locally as the <code>mydbuser</code> user:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">psql</span> -U mydbuser -d mydb -h 127.0.0.1</code></pre></div>
<h3 id="testing-the-api">Testing the API</h3>
<p>Now that PostgreSQL is setup correctly, the application can be run with the following command:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">stack</span> exec -- servant-on-heroku-api
<span class="ex">running</span> servant-on-heroku on port 8080...</code></pre></div>
<p>Let’s try sending a comment. With the application still running, try the following command:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request POST \
    --header <span class="st">'Content-Type: application/json'</span> \
    --data <span class="st">'{&quot;author&quot;: &quot;DG&quot;, &quot;text&quot;: &quot;Pretty good&quot;}'</span> \
    <span class="st">'http://localhost:8080/add-comment'</span>
<span class="kw">{</span> <span class="st">&quot;text&quot;</span>: <span class="st">&quot;Pretty good&quot;</span>, <span class="st">&quot;author&quot;</span>: <span class="st">&quot;DG&quot;</span> <span class="kw">}</span></code></pre></div>
<p>Now let’s list all the comments:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request GET \
    --header <span class="st">'Content-Type: application/json'</span> \
    <span class="st">'http://localhost:8080/get-comments'</span>
[{<span class="st">&quot;text&quot;</span>:<span class="st">&quot;Pretty good&quot;</span>,<span class="st">&quot;author&quot;</span>:<span class="st">&quot;DG&quot;</span>} ]</code></pre></div>
<p>Looks like it’s working. Now let’s try with Docker!</p>
<h2 id="running-the-application-locally-with-docker">Running the application locally WITH Docker</h2>
<p><a href="https://www.docker.com/">Docker</a> is used to build and run the application inside a container. The following section assumes basic familiarity with Docker.</p>
<h3 id="installing-docker">Installing Docker</h3>
<p>Docker is installed differently on different platforms. Check your platform documentation for more advice. For instance, here are the instructions for installing on <a href="https://wiki.archlinux.org/index.php/Docker#Installation">Arch Linux</a> and <a href="https://docs.docker.com/engine/installation/linux/ubuntu/">Ubuntu</a>.</p>
<p>After installing Docker, make sure it is running with the following command:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> info</code></pre></div>
<h3 id="building-with-docker">Building with Docker</h3>
<p>We will build the application inside of Docker and create a docker image for the application.</p>
<p>Use <code>docker build</code> to build a Docker image for the application:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> build -t servant-on-heroku .</code></pre></div>
<p>This uses the <a href="https://github.com/cdepillabout/servant-on-heroku/blob/master/Dockerfile"><code>Dockerfile</code></a> in the current directory to build the application. The <code>Dockerfile</code> lists all the steps to build the application and create a reusable image.</p>
<p>If you take a look at the <code>Dockerfile</code>, you can see that it is performing the following steps:</p>
<ol style="list-style-type: decimal">
<li>Install required packages with <code>apt-get</code>.</li>
<li>Install <code>stack</code>.</li>
<li>Install GHC using <code>stack</code> based on the application’s <code>stack.yaml</code> file.</li>
<li>Install Haskell dependencies for the application using the application’s <code>.cabal</code> file.</li>
<li>Building the application with <code>stack</code>.</li>
<li>Create a non-root user to use to run the application.</li>
<li>Run the application.</li>
</ol>
<p><code>docker build</code> can take up to one hour to finish creating the <code>servant-on-heroku</code> image.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<h3 id="testing-the-api-with-docker">Testing the API with Docker</h3>
<p>Once <code>docker build</code> finishes, <code>docker images</code> can be used to list all local images:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> images
<span class="ex">REPOSITORY</span>           TAG       IMAGE ID       CREATED         SIZE
<span class="ex">servant-on-heroku</span>    latest    ff591d372461   30 seconds ago  3.92 GB
<span class="ex">...</span></code></pre></div>
<p>You can see the <code>servant-on-heroku</code> image that was just created.</p>
<p>Let’s try running the <code>servant-on-heroku</code> image. This will run the application in Docker:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> run --interactive --tty --rm servant-on-heroku</code></pre></div>
<p>Oh no! It looks like the PostgreSQL problem is back:</p>
<pre><code>servant-on-heroku-api: libpq: failed (could not connect to server: Connection refused
        Is the server running on host &quot;localhost&quot; (::1) and accepting
        TCP/IP connections on port 5432?
could not connect to server: Connection refused
        Is the server running on host &quot;localhost&quot; (127.0.0.1) and accepting
        TCP/IP connections on port 5432?
)</code></pre>
<p>What’s happening here? Well, since the <code>servant-on-heroku</code> container is running as a Docker container, by default it can’t see our local network. It can’t see that PostgreSQL is running on <code>localhost:5432</code>.</p>
<p>Here’s a small trick we can use. When running the <code>servant-on-heroku</code> container, we can tell Docker to just let the container use our local network interface. That way, it can see PostgreSQL:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> run --interactive --tty --rm --network host servant-on-heroku
<span class="ex">running</span> servant-on-heroku on port 8080...</code></pre></div>
<p>With the <code>servant-on-heroku</code> container running, let’s try the <code>curl</code> commands from the previous section. Posting a comment:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request POST \
    --header <span class="st">'Content-Type: application/json'</span> \
    --data <span class="st">'{&quot;author&quot;: &quot;EK&quot;, &quot;text&quot;: &quot;Not enough CT&quot;}'</span> \
    <span class="st">'http://localhost:8080/add-comment'</span>
<span class="kw">{</span> <span class="st">&quot;text&quot;</span>: <span class="st">&quot;Not enough CT&quot;</span>, <span class="st">&quot;author&quot;</span>: <span class="st">&quot;EK&quot;</span> <span class="kw">}</span></code></pre></div>
<p>Getting the comments:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request GET \
    --header <span class="st">'Content-Type: application/json'</span> \
    <span class="st">'http://localhost:8080/get-comments'</span>
[{<span class="st">&quot;text&quot;</span>:<span class="st">&quot;Pretty good&quot;</span>,<span class="st">&quot;author&quot;</span>: <span class="st">&quot;DG&quot;</span>},{<span class="st">&quot;text&quot;</span>:<span class="st">&quot;Not enough CT&quot;</span>,<span class="st">&quot;author&quot;</span>:<span class="st">&quot;EK&quot;</span>}]</code></pre></div>
<p>By the way, in order to open a shell and inspect the image by hand, the following command can be used:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">docker</span> run --interactive --tty --rm --network host servant-on-heroku /bin/bash</code></pre></div>
<p>Now that we are confident our application works in Docker, it’s time for Heroku.</p>
<h2 id="heroku">Heroku</h2>
<p>Once we have the application building and running successfully in Docker, it’s easy to move to Heroku. The first step is creating a Heroku account.</p>
<h3 id="creating-an-account">Creating an Account</h3>
<p>Go <a href="https://signup.heroku.com">here</a> to sign up for a Heroku account. If you already have a Heroku account, you can skip this step.</p>
<p>We will deploy the application using Heroku’s “Free” tier, so you don’t need to worry about registering a credit card.</p>
<p>The majority of the instructions in this section are condensed from Heroku’s <a href="https://devcenter.heroku.com/articles/container-registry-and-runtime">own documentation</a> on integrating with Docker. Check out their documentation if anything is unclear.</p>
<h3 id="install-the-heroku-cli-application">Install the Heroku CLI Application</h3>
<p>Heroku provides a CLI application to make it easy to work with their service. This is similar to <a href="https://aws.amazon.com/cli">AWS’s CLI</a> or <a href="https://github.com/digitalocean/doctl">Digital Ocean’s CLI</a>.</p>
<p>On Arch Linux, Heroku’s CLI application can be installed with the following command:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">yaourt</span> -S heroku-toolbelt</code></pre></div>
<p>This installs the <code>heroku</code> binary to the system.</p>
<p>Instructions for other platforms can be found on <a href="https://devcenter.heroku.com/articles/heroku-cli">Heroku’s site</a>.</p>
<p>Once the CLI application has been downloaded, it can be used to login and authenticate with Heroku’s API:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> login</code></pre></div>
<p>You will be asked for the username and password of the account you just created.</p>
<h3 id="create-an-application-on-heroku">Create an Application on Heroku</h3>
<p>The first step of releasing our Servant API to Heroku is to create a Heroku Application.</p>
<p>The following command will create a new Heroku application called <code>servant-on-heroku</code>. You may need to use a different name for your own application:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> apps:create servant-on-heroku</code></pre></div>
<p>The following command lists information about the application just created (although it won’t be too interesting yet):</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> apps:info servant-on-heroku
=== <span class="ex">servant-on-heroku</span>
<span class="ex">Auto</span> Cert Mgmt: false
<span class="ex">Dynos</span>:
<span class="ex">Git</span> URL:        https://git.heroku.com/servant-on-heroku.git
<span class="ex">Owner</span>:          me@gmail.com
<span class="ex">Region</span>:         us
<span class="ex">Repo</span> Size:      0 B
<span class="ex">Slug</span> Size:      0 B
<span class="ex">Stack</span>:          cedar-14
<span class="ex">Web</span> URL:        https://servant-on-heroku.herokuapp.com/</code></pre></div>
<p>Make sure to take note of the <code>Web URL</code>. It will come in handy later.</p>
<h3 id="install-heroku-docker-plugin">Install Heroku Docker Plugin</h3>
<p>The Heroku CLI application has a plugin architecture. This allows the user to install plugins that can be used to access different parts of Heroku’s API.</p>
<p>There is a plugin for using Heroku’s <a href="https://devcenter.heroku.com/articles/container-registry-and-runtime">Docker Container Registry</a>.</p>
<p>The following command can be used to install the plugin:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> plugins:install heroku-container-registry</code></pre></div>
<p>After installing the plugin, the following command can be used to make sure it works:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> container
<span class="ex">4.1.1</span></code></pre></div>
<p>It should return the version string for the plugin.</p>
<p>In order to actually use the plugin, the following command can be used to login to Heroku’s container registry.</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> container:login</code></pre></div>
<p>This adds login information for Heroku’s container registry to the file <code>~/.docker/config.json</code>:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> ~/.docker/config.json
<span class="kw">{</span>
  <span class="st">&quot;auths&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;registry.heroku.com&quot;</span>: <span class="kw">{</span>
      <span class="st">&quot;auth&quot;</span>: <span class="st">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=&quot;</span>
    <span class="kw">}</span>
  <span class="kw">}</span>
<span class="kw">}</span></code></pre></div>
<h3 id="get-the-application-running-on-heroku">Get the Application Running on Heroku</h3>
<p>In order to get the application actually running on Heroku, the following command is used:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> container:push web</code></pre></div>
<p>This builds a Docker image for the application based on the <code>Dockerfile</code> in the current directory. Internally, <code>docker build</code> is used to do this. If the image was already built in the previous step (when running <code>docker build</code> from the command line), then this <code>heroku container:push</code> command will just use the previously built image. The image is sent to Docker’s Container Registry.</p>
<p>Now let’s check <code>heroku apps:info</code> again:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> apps:info servant-on-heroku
=== <span class="ex">servant-on-heroku</span>
<span class="ex">Auto</span> Cert Mgmt: false
<span class="ex">Dynos</span>:
<span class="ex">Git</span> URL:        https://git.heroku.com/servant-on-heroku.git
<span class="ex">Owner</span>:          me@gmail.com
<span class="ex">Region</span>:         us
<span class="ex">Repo</span> Size:      0 B
<span class="ex">Slug</span> Size:      0 B
<span class="ex">Stack</span>:          cedar-14
<span class="ex">Web</span> URL:        https://servant-on-heroku.herokuapp.com/</code></pre></div>
<p>Hmm, that’s not right. See where it says <code>Dynos:</code>? A “dyno” is Heroku-lingo for a server that runs the web application. This line means that there aren’t any servers running the application.</p>
<p>In order to fix this, the <code>heroku ps:scale</code> command can be used to spin up one dyno to run the application:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> ps:scale web=1</code></pre></div>
<p>This creates one “web” dyno, which will run the Servant API.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>Now run the following command to make sure the dyno is actually running:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> ps
<span class="ex">Free</span> dyno hours quota remaining this month: 549h 2m (99%)
<span class="ex">For</span> more information on dyno sleeping and how to upgrade, see:
<span class="ex">https</span>://devcenter.heroku.com/articles/dyno-sleeping

=== <span class="ex">web</span> (Free)<span class="bu">:</span> /bin/sh -c /opt/servant-on-heroku/bin/servant-on-heroku-api (1)
<span class="ex">web.1</span>: starting 2017/03/22 19:05:04 +0900 (~ 8s ago)</code></pre></div>
<p>The output is somewhat noisy, but you can tell that there is now one web dyno running.</p>
<p>Now that the application is running, the following command can be used to access the application’s <code>Web URL</code> with curl. (The application <code>Web URL</code> can be found in the output of <code>heroku apps:info</code>.)</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request POST \
    --header <span class="st">'Content-Type: application/json'</span> \
    --data <span class="st">'{&quot;author&quot;: &quot;MS&quot;, &quot;text&quot;: &quot;Gotta make it professional&quot;}'</span> \
    <span class="st">'https://servant-on-heroku.herokuapp.com/add-comment'</span></code></pre></div>
<p>That’s strange, there appears to be another error. Let’s see how to investigate application errors on Heroku.</p>
<h3 id="debugging-application-errors">Debugging Application Errors</h3>
<p>Heroku has a really nice log system. The application’s <code>stdout</code> and <code>stderr</code> logs can be inspected with the following command:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> logs
<span class="ex">2017-03-22T10</span>:05:49 heroku[web.1]: proc start <span class="kw">`</span><span class="ex">/opt/servant-on-heroku/bin/servant-on-heroku-api</span><span class="kw">`</span>
<span class="ex">2017-03-22T10</span>:05:52 app[web.1]: servant-on-heroku-api: libpq: failed (could not connect to server: Connection refused
<span class="ex">2017-03-22T10</span>:05:52 app[web.1]:    Is the server running on host <span class="st">&quot;localhost&quot;</span> (127.0.0.1) <span class="ex">and</span> accepting
<span class="ex">2017-03-22T10</span>:05:52 app[web.1]:    TCP/IP connections on port 5432?
<span class="ex">2017-03-22T10</span>:05:52 app[web.1]: )
<span class="ex">2017-03-22T10</span>:05:52 heroku[web.1]: State changed from starting to crashed</code></pre></div>
<p>Oh no! It’s the same error that has been plaguing us this whole time. Why is it occurring again?</p>
<p>Well, it’s because we haven’t setup a PostgreSQL database on Heroku!</p>
<h3 id="postgresql-on-heroku">PostgreSQL on Heroku</h3>
<p>Heroku has <a href="https://devcenter.heroku.com/articles/heroku-postgresql">nice support</a> for PostgreSQL. Heroku provides a PostgreSQL database that can be used free-of-charge.</p>
<p>The following command can be used enable the PostgreSQL database add-on for the application:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> addons:create heroku-postgresql:hobby-dev</code></pre></div>
<p>This enables the <code>heroku-postgresql</code> add-on in the <code>hobby-dev</code> tier (which is free).</p>
<p>After enabling it, the following command can be used to make sure the PostgreSQL database has been successfully created:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> addons:info heroku-postgresql
=== <span class="ex">postgresql-tetrahedral-44549</span>
<span class="ex">Attachments</span>:  servant-on-heroku::DATABASE
<span class="ex">Installed</span> at: Wed Mar 22 2017 19:22:14 GMT+0900 (JST)
<span class="ex">Owning</span> app:   servant-on-heroku
<span class="ex">Plan</span>:         heroku-postgresql:hobby-dev
<span class="ex">Price</span>:        free
<span class="ex">State</span>:        created</code></pre></div>
<p>The database info can be checked with the <code>pg:info</code> command:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> pg:info
=== <span class="ex">DATABASE_URL</span>
<span class="ex">Plan</span>:        Hobby-dev
<span class="ex">Status</span>:      Available
<span class="ex">Connections</span>: 0/20
<span class="ex">PG</span> Version:  9.6.1
<span class="ex">Created</span>:     2017-03-22 10:22 UTC
<span class="ex">Data</span> Size:   7.2 MB
<span class="ex">Tables</span>:      1
<span class="ex">Rows</span>:        0/10000 (In compliance)
<span class="ex">Fork</span>/Follow: <span class="ex">Unsupported</span>
<span class="ex">Rollback</span>:    Unsupported
<span class="ex">Add-on</span>:      postgresql-tetrahedral-44549</code></pre></div>
<h3 id="restart-the-app">Restart the App</h3>
<p>Now that the PostgreSQL database is up and running, let’s try restarting the application:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> ps:restart</code></pre></div>
<p>Let’s take a look at the application logs again:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> logs
<span class="ex">2017-03-22T10</span>:22:15 heroku[web.1]: State changed from crashed to starting
<span class="ex">2017-03-22T10</span>:22:54 heroku[web.1]: proc start <span class="kw">`</span><span class="ex">/opt/servant-on-heroku/bin/servant-on-heroku-api</span><span class="kw">`</span>
<span class="ex">2017-03-22T10</span>:22:56 app[web.1]: Migrating: CREATe TABLE <span class="st">&quot;comment&quot;</span>(<span class="st">&quot;id&quot;</span> SERIAL8  PRIMARY KEY UNIQUE,<span class="st">&quot;author&quot;</span> VARCHAR NOT NULL,<span class="st">&quot;text&quot;</span> VARCHAR NOT NULL)
<span class="ex">2017-03-22T10</span>:22:57 heroku[web.1]: State changed from starting to up</code></pre></div>
<p>Looks like it worked this time! Finally!</p>
<p>Let’s try accessing the app using <code>curl</code> again:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request POST \
    --header <span class="st">'Content-Type: application/json'</span> \
    --data <span class="st">'{&quot;author&quot;: &quot;SPJ&quot;, &quot;text&quot;: &quot;Avoid heroku-at-all-costs&quot;}'</span> \
    <span class="st">'https://servant-on-heroku.herokuapp.com/add-comment'</span>
{<span class="st">&quot;text&quot;</span>:<span class="st">&quot;Avoid heroku-at-all-costs&quot;</span>,<span class="st">&quot;author&quot;</span>:<span class="st">&quot;SPJ&quot;</span>}</code></pre></div>
<p>And once more:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">curl</span> --request GET \
    --header <span class="st">'Content-Type: application/json'</span> \
    <span class="st">'https://servant-on-heroku.herokuapp.com/get-comments'</span>
[{<span class="st">&quot;text&quot;</span>:<span class="st">&quot;Avoid heroku-at-all-costs&quot;</span>,<span class="st">&quot;author&quot;</span>:<span class="st">&quot;SPJ&quot;</span>}]</code></pre></div>
<p>Success! Looks like everything is working well!</p>
<h3 id="how-does-the-app-on-heroku-know-how-to-connect-to-the-database">How does the app on Heroku know how to connect to the database?</h3>
<p>You may be wondering how the application running on Heroku knows how to connect to the database. Well, Heroku has configuration variables that it passes to the application as environment variables.</p>
<p>These configuration variables can be inspected with the following command:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> config
=== <span class="ex">servant-on-heroku</span> Config Vars
<span class="ex">DATABASE_URL</span>: postgres://someusername:somepassword@ec2-12-12-234-123.compute-1.amazonaws.com:5432/databasename</code></pre></div>
<p>Setting up the PostgreSQL database creates a configuration variable called <code>DATABASE_URL</code>. Heroku passes this configuration variable to the application on startup as an environment variable. As discussed in a previous section, the application uses <code>DATABASE_URL</code> to connect to the correct database<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p>Heroku’s <code>DATABASE_URL</code> can also be used to connect to the database on the command line:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">psql</span> <span class="st">&quot;</span><span class="va">$(</span><span class="ex">heroku</span> config:get DATABASE_URL<span class="va">)</span><span class="st">&quot;</span>
<span class="ex">psql</span> (9.6.1)
<span class="ex">SSL</span> connection (protocol: TLSv1.2, cipher: ECDHE-RSA-AES256-GCM-SHA384, bits: 256, compression: off)

<span class="va">databasename=</span><span class="op">&gt;</span> <span class="kw">select</span> <span class="ex">*</span> from comment<span class="kw">;</span>
 <span class="fu">id</span> <span class="kw">|</span> <span class="ex">author</span> <span class="kw">|</span>           <span class="ex">text</span>
<span class="ex">----</span><span class="kw">|</span><span class="ex">--------</span><span class="kw">|</span><span class="ex">---------------------------</span>
  <span class="ex">1</span> <span class="kw">|</span> <span class="ex">SPJ</span>    <span class="kw">|</span> <span class="ex">Avoid</span> heroku-at-all-costs
<span class="kw">(</span><span class="ex">1</span> row<span class="kw">)</span></code></pre></div>
<h3 id="future-normal-releases">Future (Normal) Releases</h3>
<p>Performing future releases of the application is extremely easy. Just run the following command:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">heroku</span> container:push web</code></pre></div>
<p>This rebuilds the docker image for the application and pushes it to Heroku’s container repository. It then restarts the dynos so they are running with the new code for the application.</p>
<h2 id="future-work">Future Work</h2>
<p>This application works pretty well, but there are a couple places for improvements. The lowest hanging fruit would probably be the <code>Dockerfile</code>. Here are a couple ideas that would make the <code>Dockerfile</code> a little better:</p>
<ul>
<li>Use a slimmer image as the base image for the <code>Dockerfile</code>. Right now it is using <a href="https://hub.docker.com/r/heroku/heroku/">Heroku’s images</a>, but I don’t think there is any reason that something like <a href="https://hub.docker.com/_/alpine/">Alpine Linux</a> couldn’t be used.</li>
<li>Base the image on something with <code>stack</code>, GHC, and popular Haskell libraries already installed. This would greatly reduce the time it takes to do the very initial <code>docker build</code>.</li>
<li>At the very end of the <code>Dockerfile</code>, remove <code>stack</code>, GHC, and all Haskell libraries. This would hopefully make the docker image a little smaller. It would take less bandwidth to send the image to Heroku’s container repository.</li>
</ul>
<p>It would also be nice to use something like <code>docker-compose</code> to setup the PostgreSQL database using Docker when running locally.</p>
<h2 id="alternatives-to-docker-for-deploying-on-heroku">Alternatives to Docker for Deploying on Heroku</h2>
<p>The only strong alternative to using Docker for deploying Haskell code to Heroku is <a href="https://haskellonheroku.com/">haskellonheroku</a>. This is a normal Heroku <a href="https://devcenter.heroku.com/articles/buildpacks">buildpack</a> for Haskell. With this buildpack, you are able to use Heroku like you would with dynamic languages. All you need to do is <code>git push</code> your code to Heroku’s remote git repository. The new code is automatically compiled and deployed.</p>
<p>This sounds really good in theory, but in pracitce haskellonheroku has two big drawbacks:</p>
<ol style="list-style-type: decimal">
<li>Heroku build times are limited to 15 minutes. haskellonheroku gets around this in a complicated way, <a href="https://haskellonheroku.com/tutorial/#build-the-sandbox">requiring use</a> of Amazon S3 to upload prebuilt libraries before doing a <code>git push</code>.</li>
<li>haskellonheroku uses <a href="https://halcyon.sh/"><code>halcyon</code></a> internally to accomplish most build steps. <code>halcyon</code> is a tool similar to <code>stack</code> and <code>nix</code>. However, it appears that development has stopped 2 years ago. <code>halcyon</code> does not support any of the latest GHC versions.</li>
</ol>
<p><code>halcyon</code> might have been nice a few years ago before <code>stack</code> existed. But now that <code>stack</code> is regularly used for Haskell development, moving to an alternative build tool doesn’t seem like a good decision.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<h2 id="related-work">Related Work</h2>
<ul>
<li><a href="https://www.reddit.com/r/haskell/comments/3iql3f/heroku_buildpack_using_stack/cujd263/">Alternative Dockerfile</a> for deploying with Docker</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>As long as you have Docker running on your local machine, it’s pretty easy to get your Haskell code on Heroku. Heroku’s free plan is nice for testing application ideas and showing them to others. It may not work for any sort of business application, but as a proof-of-concept, it’s great!</p>
<p>If you decide your proof-of-concept works well and you want to release it, it’s easy to add a credit card to Heroku and start running on their cheapest paid tier. Heroku has a very nice upgrade path.</p>
<h2 id="footnotes">Footnotes</h2>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>These seven steps are slightly complicated. Ideally, it should be possible to install GHC, install all the application dependencies, and build the application in just one command. However, I have separated it into multiple commands to take advantage of Docker’s caching ability. When re-running <code>docker build</code>, only commands where the input has changed will be re-run.</p>
<p>For example, if you change the <code>servant-on-heroku.cabal</code> file and re-run <code>docker build</code>, it will rebuild the image from (4), starting with installing dependencies from the application’s <code>.cabal</code> file. <code>docker build</code> does not have to re-run (1), (2), or (3). It uses cached versions of the image.</p>
<p>This means that if all you change is the application source code under <code>src/</code> and re-run <code>docker build</code>, all <code>docker build</code> has to do is re-run (5), (6), and (7). It doesn’t have to install GHC or the application’s Haskell dependencies. This reduces a large part of the build-time. Future builds will take just a few minutes, instead of one hour.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>There are <a href="https://devcenter.heroku.com/articles/dynos#dyno-configurations">multiple kinds</a> of dynos. However, it’s not something that we need to worry about for our simple web API.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Heroku also makes use of the <code>PORT</code> environment variable for telling your application which port to listen on.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Unless it is a tool that gives substantial extra power, like <code>nix</code>.<a href="#fnref4">↩</a></p></li>
</ol>
</div>
            </div>
        </div>
    </div>
</article>



    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="https://github.com/arow-oss">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
                    <p class="copyright text-muted">Copyright ARoW Co., Ltd. 2015</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../js/bootstrap.min.js"></script>

    <!-- Custom Theme JavaScript -->
    <script src="../js/clean-blog.js"></script>

</body>

</html>
